# 操作系统

## 1.并发和并行

**相同点**

- CPU执行多个任务的方式
- 给人宏观的感受就是程序一起执行	

**不同点**

- 并发的多个任务之间是互相抢占资源的
- 并行的多个任务之间是不互相抢占资源的

### 并发

- 在操作系统中，一个时间段中有多个进程都处于已启动运行到运行完毕之间的状态。但任一个时刻点上仍只有一个进程在运行
- 并发的实质上是宏观并行，微观串行
- 并发通过进程调度算法实现的
- 虽然 CPU 在同一时刻只能执行一个任务，但是通过将 CPU 的使用权在恰当的时机分配给不同的任务，使得多个任务在视觉上看起来是一起执行的。
- CPU 的执行速度极快，多任务切换的时间也极短。
- 并发是针对单核单cpu提出的，多核单cpu也能实现并行					

### 并行

- 并行是针对多核cpu提出的概念
- 和单核 CPU 不同，多个CPU 真正实现了同时执行多个任务

### 2.并发与并行的技术支持

- 资源分配（cpu资源，内存资源，外部设备资源，磁盘资源）
- 资源的分配原则：
  - 提高资源利用率；
  - 在合理的时间内使用所有用户都可以得到所需资源（不要出现饿死的情况）——公平；
  - 对独占资源实施互斥使用；
  - 防止因资源分配不当而引起的死锁；这些目标相互牵制，需要权衡。

- 常用资源分配策略：
  - 进程调度算法
  - 内存管理
  - 设备管理
  - 文件管理

- 其他技术
  - 英特尔超线程技术
  - 虚拟cpu

## 2.同步与异步

- 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)。
- 同步异步关注的是消息通信机制，而阻塞与非阻塞关注的是进程或者线程等待结果时的状态（继续等待就是阻塞，反之非阻塞）

### 同步

- 就是调用某个东西时，调用方得等待这个调用返回结果才能继续往后执行。

- 同步中强调的是程序执行的顺序

- 同步中一定存在阻塞状态

- 优点：

  - 易于控制
  - 时效性强，能够实时得到结果

- 缺点

  - 耦合度高（如果需要对代码进行修改，可能导致其他代码被迫更改）
  - 资源浪费（高并发情况下会造成资源浪费）
  - 级联失败（程序执行中一个环节出现错误，那么调用者都会出现错误）

  

###  异步

- 和同步相反 调用方不会理解得到结果，而是在调用发出后调用者可用继续执行后续操作，被调用者通过状体来通知调用者，或者通过回掉函数来处理这个调用
- 异步中可能存在阻塞状态，但是一定存在非阻塞状态
- 通知机制：
  - 信号（信号的实现方式：**(https://blog.csdn.net/q921374795/article/details/88840314)**）
  - 回调函数

+ 优点

  + 耦合度低

  + 提升了cpu的吞吐量

    

- 缺点

  - 难以控制

  - 使用不当会严重影响性能

    

##  3.阻塞与非阻塞

###  属性

- 在linux中，一些资源（管道文件，套接字文件，设备文件）默认是具有阻塞性质的，即在某一时刻，只能由一个进程或线程对资源进行读或者写（一些资源有读共享，写复制的特点）

  

### 概念

- 阻塞和非阻塞指的是程序等待返回**结果**时的状态

###  阻塞

- 程序有条件为满足时会陷入阻塞
- 操作系统会把被阻塞的进程加入到阻塞队列，阻塞队列会被操作系统调出内存（为了提高内存的利用率）
- 当阻塞的进程条件得到满足时加入就绪队列，会被调入内存等待执行，程序从就绪态到运行态涉及进程调度算法

### 非阻塞

- 可以手动改变一些资源的非阻塞属性（操作不当会出现比较严重的错误）
- 当程序条件不满足也不会等到条件满足

### 同步、异步、阻塞、非阻塞

- 同步阻塞： 如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成

- 异步阻塞（不常见）： 如果小明点击下载按钮之后，就一直干瞪着进度条不做其他任何事情直到软件下载完成，但是软件下载完成其实是会「叮」的一声通知的（但小明依然那样干等着）

- 同步非阻塞： 如果小明点击下载按钮之后，就去做其他事情了，不过他总需要时不时瞄一眼屏幕看软件是不是下载完成了

- 异步非阻塞： 如果小明点击下载按钮之后，就去做其他事情了，软件下载完之后「叮」的一声通知小明，小明再回来继续处理下载完的软件

  

## 4.缓冲区溢出及其危害

### 缓冲区

- 计算机程序一般都会使用到一些内存，这些内存或是程序内部使用，或是存放用户的输入数据，这样的内存一般称作缓冲区。

- 缓冲区就是一块连续的计算机内存区域，它可以保存相同数据类型的多个实例，如字符数组。

- 缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上

  

### 常见缓冲区溢出

- 栈溢出

  - 递归函数没有函数出口
  - 没有保证足够的存储空间存储复制过来的字符串(strcpy, scanf)
  - 宽度溢出（将int类型的只赋值给char型）， 算数溢出（两个数相乘超过int范围）
  - 数组索引不在合法范围
  - 空字符错误（字符串没有\0结尾）

- 堆溢出

  - malloc申请100字节的空间，却访问了第101个字节(不一定会报错，程序也未必会终止，难以察觉的错误)

- BSS溢出

- 格式化串溢出

  

### 缓冲区溢出危害

- 缓冲区溢出攻击，可以导致程序运行失败、系统关机、重新启动，或者执行攻击者的指令，比如非法提升权限。
- 在当前网络与分布式系统安全中，被广泛利用的50%以上都是缓冲区溢出，其中最著名的例子是1988年利用fingerd漏洞的蠕虫。而缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。

## 5.进程与线程

- 进程： 计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位
- 线程： 线程是执行运算的最小单位，是进程中的一个实体，是被系统独立调度和分派的基本单位
- 进程的优点：
  - 因为每个进程间独立分配资源，所以进程的独立性高，安全性高，稳定
  - 进程出现的错误比较容易定位，可再现性好
  - 通过增加CPU，就可以容易扩充性能
  - 可以尽量减少线程加锁/解锁的影响，极大提高性能，就算是线程运行的模块算法效率低也没关系

- 进程的缺点：
  - 多进程的并发性不如多线程，cpu的吞吐量不如多线程
  - 进程间的通信较为复杂，涉及内核态与用户态之间的转换影响性能
  - 创建进程与回收进程的系统开销大

- 线程的优点：
  - 提高并发性。通过线程可方便有效地实现并发性。进程可创建多个线程来执行同一程序的不同部分。
  - 开销少。创建或撤销线程比创建进程要快，所需开销很少。
  - 线程之间通信非常方便
  - 线程之间资源共享

- 线程的缺点
  - 线程之间的同步和加锁控制比较麻烦
  - 一个线程的崩溃可能影响到整个程序的稳定性
  - 到达一定的线程数程度后，即使再增加CPU也无法提高性能

### 进程与线程之间的区别

- 调度：线程作为处理器调度和分配的基本单位，而进程是作为拥有资源的基本单位

- 并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行

- 拥有资源：进程是拥有资源的一个独立单位，有自己独立的地址空间；线程不拥有系统资源，但可以访问隶属于进程的资源，共享进程的地址空间.

- 系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

  

###  进程与线程之间的关系

- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

- 资源分配给进程，同一进程的所有线程共享该进程的所有资源。

- 处理机分给线程，即真正在处理机上运行的是线程

- 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。线程是指进程内的一个执行单元,也是进程内的可调度实体

  

### 为什么有进程还要有线程

- **进程**属于在CPU和系统资源等方面提供的抽象，能够有效提高CPU的利用率。

  **线程**是在进程这个层次上提供的一层并发的抽象

  - 能够使系统在同一时间能够做多件事情
  - 当进程遇到阻塞时，例如等待输入，线程能够使不依赖输入数据的工作继续执行
  - 可以有效地利用多处理器和多核计算机，在没有线程之前，多核并不能让一个进程的执行速度提高

- 资源：线程不需要操作系统为它分配资源，但是进程需要，分配的过程开销很大

- 切换效率：因为线程共享空间，线程之间的切换只需要栈帧偏移就能实现，但是进程需要调度算法等支持

- 通信机制：线程之间共享空间，通信只需要在共享的空间内就能进行通信，但是进程间地址空间独立，进行IPC可能涉及到用户态与内核态之间的转换，开销非常大

  

## 6. 进程间通信（IPC）

进程间通信的几种方式：

- 管道（pipe， 流数据）（两端，读端写端）

  - 匿名管道（只能用于关联进程间通信）（半双工通信）

    - 局限于单向通信 
    - 只能创建在它的进程以及其有亲缘关系的进程之间
    - 缓冲区有限

  - 命名管道（可以用于非关联进程间通信）（半双工通信）

    - 需要使用命令mkfifo pipename 创建一个命名管道，或者使用mkfifo函数创建一个管道文件

    - 非关联进程需要使用管道文件来创建一个命名管道

    - 可以实现任意进程间通信
    
    - 长期存于系统中，使用不当容易出错
    
    - 缓冲区有限
    
      

- 共享内存（mmap， 流数据）（最快）

  - 进程直接拷贝向共享内存中，不需要向内核中拷贝
  - mmap是DMA（直接内存访问）引擎实现的，没有cpu的参与
  - 读写数据时的拷贝次数少，
    - 传统通信方式：磁盘(DMA) --> 内核缓冲区 --> 用户缓冲区 -->内核缓冲区 --> 磁盘
    - mmap：磁盘(DMA) --> 用户缓冲区 --> 磁盘														
  - 优点：无须复制，快捷，信息量大
  - 缺点：
    - 通信是通过将共享空间缓冲区直接附加到进程的虚拟地址空间中来实现的，因此进程间的读写操作的同步问题
    - 利用内存缓冲区直接交换信息，内存的实体存在于计算机中，只能同一个计算机系统中的诸多进程共享，不方便网络通信

- 消息队列（报数据）：
  
  - posix消息队列
- system V消息队列
  - 优点：可以实现任意进程间的通信，并通过系统调用函数来实现消息发送和接收之间的同步，无需考虑同步问题，方便
  - 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合
  
- 套接字

- 信号：一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

- 磁盘文件（非常慢，没意义）

  

## 7. 进程调度算法

- **先来先服务调度算法(FCFS)**
  - **系统将按照作业到达的先后次序来进行调度**
  - **有利于长作业，但不利于短作业**
- **短作业优先调度算法(SJF)**
  - **SJF算法是以作业的长度来计算优先级，作业越短，其优先级越高。作业的长短是作业所要求的运行时间来衡量的**
  - 有利于短作业，不利于长作业
  - 缺点：
    - 必须知道作业的运行时间(只能程序员估计)
    - 不利于长作业，容易产生饥饿现象
    - 无法实现人机交互
    - 没有考虑到作业紧迫程度 
- **优先级调度算法(PSA)**
  - 优先级通常由外部指定，高优先级算法优先调入内存分配资源
  - 对于FCFS调度算法，等待时间越长，优先级越高
  - 对于SJF算法，运行时间越短，优先级越高
- **高相应比优先调度算法(HRRN)**



##  8. 分页和分段的区别

### 内存分段：

- 内存分段是**操作管理虚拟地址与物理地址之间关系**的方式之一
- 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来**

- 内存分段下，程序只能使用和访问虚拟地址，真实地址需要通过MMU转换
- 虚拟地址是通过**段表**与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址



### 内存分段缺点

- 存在内存碎片
  - 内碎片
  - 外碎片: 内存交换进行解决
- 内存交换效率低



### 内存分页

- **分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**（linux下每一页大小为4096B）
- 虚拟地址与物理地址之间通过页表进行映射



**内存映射**

页表实际上存储在 CPU 的**内存管理单元** （*MMU*） 中，于是 CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。

而当进程访问的虚拟地址在页表中查不到时，系统会产生一个**缺页异常**，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。

分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，**页表**包含物理页每页所在**物理内存的基地址**，这个基地址与页内偏移的组合就形成了物理内存地址

![image-20230328153909805](../../AppData/Roaming/Typora/typora-user-images/image-20230328153909805.png)



**内存分页解决内存碎片与内存交换效率问题**

- 由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而**采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。**
- 如果内存空间不够，操作系统会把其他正在运行的进程中的的内存页面给释放掉，也就是暂时写在硬盘上，称为**换出**（*Swap Out*）。一旦需要的时候，再加载进来，称为**换入**（*Swap In*）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，**内存交换的效率就相对比较高。**
- 程序的局部性原理： 操作系统不会一次性将程序所需要的页面一次性加载进内存，而是程序运行时需要那个页在为那个页分配内存，建立内存映射



### 内存分页的缺点

- 页表占用空间过大

  - 每个进程都有独立的虚拟地址空间，那么每一个进程就都需要维护自己的页表
  - 操作系统一旦进程数量很大，就需要更多的空间区维护页表

  

**使用多级页表解决页表占用空间过大的问题**

- 多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。
- 程序是有局部性的，即在一段时间内，**整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。**



**Cache**

- 最常访问的几个页表项存储到访问速度更快的硬件，在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的 Cache，这个 Cache 就是 TLB（*Translation Lookaside Buffer*） ，通常称为页表缓存、转址旁路缓存、快表等。
- 在 CPU 芯片里面，封装了内存管理单元（*Memory Management Unit*）芯片，它用来完成地址转换和 TLB 的访问与交互。
- 有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。
- TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。



**段页式内存管理**

段页式地址变换中要得到物理地址须经过三次内存访问：

- 第一次访问段表，得到页表起始地址；
- 第二次访问页表，得到物理页号；
- 第三次将物理页号与页内位移组合，得到物理地址。



**内存分段与分页的区别**

1. 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的;页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的;
2. 段的大小不固定，有它所完成的功能决定;页大大小固定，由系统决定;
3. 段向用户提供二维地址空间;页向用户提供的是一维地址空间;
4. 段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。



**物理地址、逻辑地址、虚拟内存的概念**

1. 物理地址: 它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
2. 逻辑地址: **是指计算机用户看到的地址。**例如:当创建一个长度为100的整型数组时，操作系统返回一个逻辑上的连续空间:指针指向数组第一个元素的内存地址。由于整型元素的大小为4个字节，故第二个元素的地址时起始地址加4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。
3. 虚拟内存: **是计算机系统内存管理的一种技术**。它使得应用程序认为它拥有连续的可用的内存(一个连续完整的地址空间)，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。



## 9. 抖动

**抖动定义**： 刚刚换出内存的页面马上又要换入内存，刚刚换入的页面又马上换出内存的现象

**产生原因**： 进程频繁访问的页面数目高于可用的物理块数



## 10.常见的内存的分配错误





## 11. 内存交换中，被换出的进程存在那里

## 12. 死锁

### 什么是死锁

- 死锁是一组相互竞争资源的线程因为他们之间得到互相等待导致“永久“阻塞的现象

  

### 死锁产生原因

- 系统资源不足
- 资源分配不当
- 进程运行推进顺序不当



### 死锁产生的四个必要条件

- 互斥

- 请求与保持

- 不可抢占

- 循环等待

  

### 解决死锁

- **预防死锁**(针对死锁产生的必要条件)
  - 打破互斥条件：改造独占性资源为虚拟资源，大部分资源已无法改造。
  - 打破请求与保持条件： 在程序初期就分配该线程所需要的所有资源，缺少资源不能执行(资源浪费，容易产生饥饿现象)。优化：允许程序获得初期需要的资源就开始执行，在执行过程中在逐步释放不需要的资源
  - 打破不可抢占条件： 当一进程占有互斥资源后又申请互斥资源而无法满足，则释放原占有的资源。
  - 打破循环等待条件： 实现资源有序分配策略，对所有设备实现分类编号，所有进程只能采用按序号递增的形式申请资源。
- **避免死锁**
  - 银行家算法
- 检测死锁
- **解除死锁**
  - 优先将互斥资源分配给已经死锁的进程
  - 撤销进程

### 



## 几种典型的锁











